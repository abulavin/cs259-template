/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package PLMParser;

import org.junit.Test;

import static org.junit.Assert.*;
import org.json.simple.*;
import org.json.simple.parser.*;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class AssignmentTest {

    /**
     * Run all the test cases under src/test/resources by loading tests.json to get the expected results
     * for each file, then loading each file individually and asserting that the values the parser 
     * returns equal the expected values from the JSON file.
     */
    @Test
    public void testCanIdentifyValidAndInvalidPrograms() {
        JSONObject tests = loadJSON("tests.json");
        for (Object key : tests.keySet()) {
            String filename = (String) key;
            InputStream targetStream = loadFileAsInputStream(filename);

            String[] streams = runParserAndReturnStdStreams(targetStream);
            String outputString = streams[0];
            String errorString = streams[1];

            List solution = getTestSolutionFromJson(filename, tests);
            List<String> testDetails = getTestDetails(solution);
            String passOrFail = getPassOrFail(solution);

            if (passOrFail.equals("PASS")) {
                String result = testDetails.get(1);
                shouldPass(outputString, errorString, filename);
                assertTrue(String.format("Result incorrect for file %s Expected: %s Got:\n%s", filename, result,
                outputString), outputCorrect(outputString, result)); 
            } else if (passOrFail.equals("FAIL")) {
                String errorLine = getErrorLine(solution);
                shouldFail(outputString, errorString, filename);
                assertTrue(String.format("Error line incorrect for file %s Expected: %s Got:\n%s", filename, errorLine,
                        errorString), errorLineCorrect(errorString, errorLine));
            } else {
                throw new AssertionError("passOrFail should be either PASS or FAIL");
            }
        }
    }
    
    /**
     * Load the json file under src/test/resources as a JSONObject
     * @param jsonFile Name of the json file
     * @return JSONObject
     */
    private JSONObject loadJSON(String jsonFile) {
        InputStream json = ClassLoader.getSystemClassLoader().getResourceAsStream(jsonFile);
        JSONParser jsonParser = new JSONParser();
        JSONObject jsonObject = null;
        try {
            jsonObject = (JSONObject) jsonParser.parse(new InputStreamReader(json, "UTF-8"));
        } catch (Exception e) {
            fail(e.getMessage());
        }
        if(json == null) {
            fail("The JSON file failed to load.");
        }
        return jsonObject;
    }

    /**
     * Load a text file as an InputStream to pass to the parser as input.
     * @param filename Name of the text file.
     * @return Input stream containing the exact contents of the file.
     */
    private InputStream loadFileAsInputStream(String filename) {
        return ClassLoader.getSystemClassLoader().getResourceAsStream(filename);
    }

    /**
     * Run the JavaCC Parser Class (Assignment) and return an array containing
     * the contents of StandardOut and StandardErr (in that order) as Strings
     * @param targetStream Input stream containing the contents of the test file.
     * @return String Array A[1..2] where A[0] = stdout and A[1] = stderr
     */
    private String[] runParserAndReturnStdStreams(InputStream targetStream) {
        String utf8 = StandardCharsets.UTF_8.name();
        String[] streams = new String[2];
        try {
            final ByteArrayOutputStream outputBytes = new ByteArrayOutputStream();
            final ByteArrayOutputStream errorBytes = new ByteArrayOutputStream();
            PrintStream output = new PrintStream(outputBytes, true, utf8);
            PrintStream error = new PrintStream(errorBytes, true, utf8);

            Assignment parserUnderTest = new Assignment(targetStream);
            parserUnderTest.parse(output, error);

            streams[0] = outputBytes.toString(utf8);
            streams[1] = errorBytes.toString(utf8);
        } catch (UnsupportedEncodingException encoding) {
            fail(encoding.toString());
        } catch (Exception e) {
            fail(e.toString());
        }
        return streams;
    }

    private List getTestSolutionFromJson(String testFile, JSONObject json) {
        return (List) json.get(testFile);
    }

    private List<String> getTestDetails(List solutions) {
        return (List<String>) solutions.get(0);
    }

    private String getPassOrFail(List solutions) {
        return (String) ((List<String>) solutions.get(0)).get(0);
    }

    private String getErrorLine(List solutions) {
        return (String) solutions.get(1);
    }

    /**
     * Create an InputStream from a text file.
     * @param filename Name of the txt file.
     * @return InputStream containing the exact contents of the text file.
     */
    private InputStream createStreamFromFile(String filename) {
        InputStream stream = null;
        try {
            File f = new File(filename);
            stream = new FileInputStream(f);
        } catch (FileNotFoundException e) {
            fail(e.getMessage());
        }
        assert stream != null;
        return stream;
    }

    /**
     * Create an InputStream from a String.
     * @param testString String representing a Test program.
     * @return InputStream containing the exact contents of the String
     */
    private InputStream createStreamFromString(String testString) {
        return new ByteArrayInputStream(testString.getBytes());
    }


    private void shouldFail(String outputString, String errorString) {
        assertTrue("Output Stream doesn't contain FAIL: " + outputString, outputString.contains("FAIL"));
        assertTrue("Error String is empty", errorString.length() > 0);
    }

    private void shouldPass(String outputString, String errorString) {
        assertTrue(outputString + "does not contain PASS", outputString.contains("PASS\n"));
        assertTrue(errorString + "is non-empty for valid program: " + errorString, errorString.length() == 0);
    }

    private void shouldFail(String outputString, String errorString, String file) {
        assertTrue("Output Stream for file " + file + " doesn't contain FAIL: " + outputString,
                outputString.contains("FAIL"));
        assertTrue("Error String is empty for file " + file, errorString.length() > 0);
    }

    private void shouldPass(String outputString, String errorString, String file) {
        assertTrue(outputString + "does not equal PASS for file " + file, outputString.contains("PASS\n"));
        assertTrue(errorString + "is non-empty for valid program: " + file, errorString.length() == 0);
    }

    /**
     * Check the output for a PASSING program is correct.
     * @param outputString The stdout stream of the parser after parsing a test file.
     * @param expected The outcome we expect to get from parsing the test file
     * @return True if the parser returns the expected value, false otherwise.
     */
    private boolean outputCorrect(String outputString, String expected) {
        String[] lines = outputString.split("\n");
        if (lines[1].contains("DIVERGENCE")) {
            return lines[1].equals(expected);
        } else {
            return Integer.parseInt(lines[1]) == Integer.parseInt(expected);
        }
    }

    /**
     * Check the error line from the error stream is correct for a FAILING test.
     * @param errorString The stderr stream of the parser after parsing a test file.
     * @param errorLine The error line number we expect to see after running the parser
     * @return True if the parser returned the expected erroneous line number, false otherwise.
     */
    private boolean errorLineCorrect(String errorString, String errorLine) {
        String lines[] = errorString.split("\n");
        return Integer.parseInt(lines[0]) == Integer.parseInt(errorLine);
    }
}
